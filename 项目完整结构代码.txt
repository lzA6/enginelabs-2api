项目 'enginelabs-2api' 的结构树:
📂 enginelabs-2api/
    📄 .env
    📄 .env.example
    📄 Dockerfile
    📄 docker-compose.yml
    📄 main.py
    📄 nginx.conf
    📄 requirements.txt
    📂 app/
        📂 core/
            📄 __init__.py
            📄 config.py
        📂 providers/
            📄 __init__.py
            📄 base_provider.py
            📄 enginelabs_provider.py
        📂 utils/
            📄 sse_utils.py
================================================================================

--- 文件路径: .env ---

# [最终生产配置 v5.0]
# API_MASTER_KEY 已设置。
# CLERK_COOKIE 已从您的原始抓包数据中自动填充。

# --- 核心安全配置 ---
API_MASTER_KEY=1

# --- 部署配置 ---
NGINX_PORT=8089

# --- Clerk 认证凭证 ---
CLERK_COOKIE="_cfuvid=dPYSpA0MmuEfGfqYRM035h98ti.6eeEzvWsMxTc7ucQ-1760709424362-0.0.1.1-604800000; _ga=GA1.1.978033660.1760709426; _hjSession_3492377=eyJpZCI6ImM1Yzg3YWY2LTkxMDQtNDVhOS04ZDIzLTk3YmFiZDA2YjcwZiIsImMiOjE3NjA3MDk0MjYzMzYsInMiOjAsInIiOjAsInNiIjowLCJzciI6MCwic2UiOjAsImZzIjoxLCJzcCI6MH0=; __cf_bm=VI57AHhk59VNP5SXo8ysWUmGAUttoVNId6dvMG3HuOk-1760709453-1.0.1.1-v0KXcL6iH4.RGl1OcjAapluWFxzUIl2GIlBRZmkxnX2o7ZWm0uJ9QSSgKrvn66NKLvvU8Oq0sD57E3zjg.jeS1MgxTjgReONPi4PiTAWEbpif77b7z6kgKRcebE5urIM; __client=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImNsaWVudF8zNENGMGxVUENlQjNoT2ZjOVhDSFdETk9lVXoiLCJyb3RhdGluZ190b2tlbiI6Im5kaHZ3bGo2ZHVqenJhMzUybzF1MTRtaG12NXhiYmE3c2doeG1zMHkifQ.WLfPgTp_EtMQVgQith_4-HVcR4E0YOAaJALY7e4yuRTByoat2_RJsJ3Z1-QMK30VggOk6_nYd_6GlQL6FkcmvEYPS1zKPiOv7eqoQC931_J3c3L3w4l8rG1wSCcNEpSfDRPHnAYnySSTrxlt_uXoBLxzE_jBpZTdd4MgpBQeAXoHU0DK-oRTu_K420SlXYQotGmNUPlwB18We_jxgEWjIFajXNS6HR_EfGKmCuXaktZJBjPkbAjixlTtCiE9lopmLA2mCay78fqzd_TC5SgJaYzIRSdhneVPfjNlww4SmGnF5YbFrsNADrzGJuAe-dieaKrjYUw4a-UPZZRMO6dIow; _hjSessionUser_3492377=eyJpZCI6IjY1YzdmNjRlLTM1YmUtNWJmZS04ZTQxLTZhOTIyMmM5MzA4MyIsImNyZWF0ZWQiOjE3NjA3MDk0MjYzMzUsImV4aXN0aW5nIjp0cnVlfQ==; __client_uat=1760709474; __client_uat_LUZhIdZf=1760709474; _ga_YXQL57VHZ5=GS2.1.s1760709425$o1$g1$t1760710084$j43$l0$h0; _ga_H9LTP678KS=GS2.1.s1760709425$o1$g1$t1760710084$j43$l0$h0; _gcl_au=1.1.1896293932.1760709426.1309957906.1760709967.1760710084"


--- 文件路径: .env.example ---

# ====================================================================
# enginelabs-2api 配置文件模板 (v4.0 - 自主认证版)
# ====================================================================

# --- 核心安全配置 (必须设置) ---
# 用于保护您 API 服务的访问密钥。
API_MASTER_KEY=lzA6_enginelabs_2api_key

# --- 部署配置 (可选) ---
# Nginx 对外暴露的端口
NGINX_PORT=8089

# --- Clerk 认证凭证 (必须设置) ---
# 这是实现自动获取令牌的关键。请从浏览器开发者工具中获取。
# 详细步骤请参考 README.md。
CLERK_COOKIE="eyJhbGciOiJSUzI1NiIsImNhdCI6ImNsX0I3ZDRQRDExMUFBQSIsImtpZCI6Imluc18yUkhSa1NDcVVUUEowbzlUU3FUdnA2OFlmdlQiLCJ0eXAiOiJKV1QifQ.eyJhenAiOiJodHRwczovL2N0by5uZXciLCJleHAiOjE3NjA3MTA3MzAsImZ2YSI6WzE5LC0xXSwiaWF0IjoxNzYwNzEwNjcwLCJpc3MiOiJodHRwczovL2NsZXJrLmN0by5uZXciLCJuYmYiOjE3NjA3MTA2NjAsIm8iOnsiaWQiOiJvcmdfMzRDRzBUR0VZSFlQUFVFVkM2eGlZN3FBRlVPIiwicm9sIjoiYWRtaW4iLCJzbGciOiJsemE2LTE3NjA3MDk5MTYifSwic2lkIjoic2Vzc18zNENGNnJ4Z0hydmJvQ2lybTNrNXNWSkwyTEYiLCJzdHMiOiJhY3RpdmUiLCJzdWIiOiJ1c2VyXzM0Q0Y2djBnYmw1V292ck5xZ09aeFBBbmc2OSIsInYiOjJ9.F0x_F1N9g4pjxTswo7pRCIyWptZ7C4dXFemAeErZy8mgUFDqRGaGYlYGTTz0NT7geQ1OxDnIVVu9Nqyptt6PPn1hUG_wDwE90C-jfhmKFr2iG_ezyrR7IvtmRhm788K2-fmMYkgIdUoyIBk4HtW7KeErpWEmg4SoVb59GghMd_S7cFSRBARZDCDh1gsEjeS3IMF5zzElEUrAnxWYf9rFHFe5T63je-1azgM3NabSOIzS7zUYImtrB63Csdk8Ib5LfVLtkjQ9Rv4z7GwtfsgUMNQ--tVVMYAGtZA50RQ_fzc7NmDqOwW_j12HHchydYaQ1DF6SCzjjZm9GcaVSTRTQg"


--- 文件路径: Dockerfile ---

# ====================================================================
# Dockerfile for wald-2api
# ====================================================================

FROM python:3.10-slim

# 设置环境变量
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
WORKDIR /app

# 安装 Python 依赖
COPY requirements.txt .
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 创建并切换到非 root 用户
RUN useradd --create-home appuser && \
    chown -R appuser:appuser /app
USER appuser

# 暴露端口并启动
EXPOSE 8000
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "1"]


--- 文件路径: docker-compose.yml ---

services:
  nginx:
    image: nginx:latest
    container_name: enginelabs-2api-nginx
    restart: always
    ports:
      - "${NGINX_PORT:-8089}:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - app
    networks:
      - enginelabs-net

  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: enginelabs-2api-app
    restart: unless-stopped
    env_file:
      - .env
    networks:
      - enginelabs-net

networks:
  enginelabs-net:
    driver: bridge


--- 文件路径: main.py ---

import logging
from contextlib import asynccontextmanager
from typing import Optional

from fastapi import FastAPI, Request, HTTPException, Depends, Header
from fastapi.responses import JSONResponse, StreamingResponse

from app.core.config import settings
from app.providers.enginelabs_provider import EngineLabsProvider

# --- 日志配置 ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- 全局 Provider 实例 ---
provider = EngineLabsProvider()

# --- FastAPI Lifespan 管理 ---
@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info(f"启动应用: {settings.APP_NAME} v{settings.APP_VERSION}")
    logger.info("协议: 凤凰协议 (Project Phoenix) | v4.0 自主认证版")
    logger.info("认证模式: 全自动令牌续期")
    logger.info(f"服务将在 http://localhost:{settings.NGINX_PORT} 上可用")
    yield
    logger.info("应用关闭。")

# --- FastAPI 应用实例 ---
app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    description=settings.DESCRIPTION,
    lifespan=lifespan
)

# --- 依赖项：API Key 验证 ---
async def verify_api_key(authorization: Optional[str] = Header(None)):
    if settings.API_MASTER_KEY:
        if not authorization or "bearer" not in authorization.lower():
            raise HTTPException(status_code=401, detail="需要提供 Master API Key 进行认证 (Bearer Token)。")
        token = authorization.split(" ")[-1]
        if token != settings.API_MASTER_KEY:
            raise HTTPException(status_code=403, detail="无效的 Master API Key。")

# --- API 路由 ---
@app.post("/v1/chat/completions", dependencies=[Depends(verify_api_key)])
async def chat_completions(request: Request):
    """
    处理聊天补全请求。认证信息由服务全自动处理。
    """
    try:
        request_data = await request.json()
        # 【调用简化】: 不再需要传递任何令牌
        return await provider.chat_completion(request_data)

    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"处理聊天请求时发生顶层错误: {e}", exc_info=True)
        return JSONResponse(status_code=500, content={"error": {"message": f"内部服务器错误: {str(e)}", "type": "internal_server_error"}})

@app.get("/v1/models", dependencies=[Depends(verify_api_key)], response_class=JSONResponse)
async def list_models():
    return await provider.get_models()

@app.get("/", summary="根路径", include_in_schema=False)
def root():
    return {"message": f"欢迎来到 {settings.APP_NAME} v{settings.APP_VERSION}. 服务运行正常。"}


--- 文件路径: nginx.conf ---

worker_processes auto;

events {
    worker_connections 1024;
}

http {
    upstream enginelabs_backend {
        # ip_hash 保证同一客户端的多个请求（如果发生）被路由到同一 worker，
        # 虽然对于无状态 API 不是必须，但作为良好实践保留。
        ip_hash;
        server app:8000;
    }

    server {
        listen 80;
        server_name localhost;

        location / {
            proxy_pass http://enginelabs_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # --- 流式传输优化 ---
            proxy_buffering off;
            proxy_cache off;
            proxy_set_header Connection '';
            proxy_http_version 1.1;
            chunked_transfer_encoding off;
        }
    }
}


--- 文件路径: requirements.txt ---

fastapi
uvicorn[standard]
pydantic-settings
python-dotenv
cloudscraper
websockets
PyJWT


--- 文件路径: app\core\__init__.py ---



--- 文件路径: app\core\config.py ---

from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import List, Optional

class Settings(BaseSettings):
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding='utf-8',
        extra="ignore"
    )

    APP_NAME: str = "enginelabs-2api"
    APP_VERSION: str = "4.0.0-Phoenix"
    DESCRIPTION: str = "一个将 cto.new (EngineLabs) API 转换为兼容 OpenAI 格式的高性能代理。实现全自动令牌续期，一劳永逸。"

    # --- 安全与网络 ---
    API_MASTER_KEY: Optional[str] = None
    NGINX_PORT: int = 8089
    API_REQUEST_TIMEOUT: int = 300

    # --- Clerk 认证凭证 ---
    CLERK_COOKIE: Optional[str] = None

    # --- 模型配置 ---
    DEFAULT_MODEL: str = "ClaudeSonnet4_5"
    KNOWN_MODELS: List[str] = ["ClaudeSonnet4_5", "GPT5"]

settings = Settings()


--- 文件路径: app\providers\__init__.py ---



--- 文件路径: app\providers\base_provider.py ---

from abc import ABC, abstractmethod
from typing import Dict, Any
from fastapi.responses import StreamingResponse, JSONResponse

class BaseProvider(ABC):
    @abstractmethod
    async def chat_completion(
        self,
        request_data: Dict[str, Any]
    ) -> StreamingResponse:
        pass

    @abstractmethod
    async def get_models(self) -> JSONResponse:
        pass


--- 文件路径: app\providers\enginelabs_provider.py ---

import json
import time
import logging
import uuid
import jwt
import cloudscraper
import websockets
import hashlib
from typing import Dict, Any, AsyncGenerator, Optional

from fastapi import HTTPException
from fastapi.responses import StreamingResponse, JSONResponse

from app.core.config import settings
from app.providers.base_provider import BaseProvider
from app.utils.sse_utils import create_sse_data, create_chat_completion_chunk, DONE_CHUNK

logger = logging.getLogger(__name__)

class EngineLabsProvider(BaseProvider):
    """
    Provider for EngineLabs API.
    v10.0: The Final Truth. This version combines all successful learnings:
    - Autonomous JWT refresh using cookies.
    - Server-side context memory using a message hash cache.
    - Reverted to the simple 'prompt' string format, which is the only one accepted by the server.
    This is the definitive, stable, and fully functional version.
    """
    def __init__(self):
        if not settings.CLERK_COOKIE:
            raise ValueError("配置错误: CLERK_COOKIE 必须在 .env 文件中设置。")
        
        self.scraper = cloudscraper.create_scraper()
        self.chat_url = "https://api.enginelabs.ai/engine-agent/chat"
        
        self.clerk_cookie = settings.CLERK_COOKIE.strip()
        
        self.session_id = "sess_34CF6rxgHrvboCirm3k5sVJL2LF"
        self.organization_id = "org_34CG0TGEYHYPPUEVC6xiY7qAFUO"
        
        self.token_url = f"https://clerk.cto.new/v1/client/sessions/{self.session_id}/tokens?__clerk_api_version=2025-04-10"
        
        self.conversation_cache: Dict[str, str] = {}
        
        logger.info("EngineLabsProvider 已初始化 (真理协议 v10.0)，服务已就绪。")

    async def _get_fresh_jwt(self) -> str:
        logger.info("正在请求新的 JWT 令牌...")
        headers = {
            "Cookie": self.clerk_cookie,
            "Content-Type": "application/x-www-form-urlencoded",
            "Origin": "https://cto.new",
            "Referer": "https://cto.new/",
        }
        form_data = { "organization_id": self.organization_id }
        try:
            response = self.scraper.post(self.token_url, headers=headers, data=form_data)
            response.raise_for_status()
            data = response.json()
            new_jwt = data.get("jwt")
            if not new_jwt: raise ValueError("响应中缺少 'jwt' 字段。")
            logger.info("成功获取新的 JWT 令牌。")
            return new_jwt
        except Exception as e:
            logger.error(f"获取新 JWT 令牌失败: {e}", exc_info=True)
            raise HTTPException(status_code=500, detail=f"无法从 Clerk 自动获取认证令牌: {e}")

    def _get_conversation_fingerprint(self, messages: list) -> str:
        if not messages:
            return "empty"
        history_str = json.dumps(messages, sort_keys=True)
        return hashlib.md5(history_str.encode('utf-8')).hexdigest()

    async def chat_completion(self, request_data: Dict[str, Any]) -> StreamingResponse:
        
        jwt_token = await self._get_fresh_jwt()
        user_id = jwt.decode(jwt_token, options={"verify_signature": False}).get("sub")
        
        model = request_data.get("model", settings.DEFAULT_MODEL)
        messages = request_data.get("messages", [])
        
        history_messages = messages[:-1]
        fingerprint = self._get_conversation_fingerprint(history_messages)
        
        if fingerprint in self.conversation_cache:
            chat_history_id = self.conversation_cache[fingerprint]
            logger.info(f"在缓存中找到对话指纹 '{fingerprint}'，复用 chatHistoryId: {chat_history_id}")
        else:
            chat_history_id = str(uuid.uuid4())
            self.conversation_cache[fingerprint] = chat_history_id
            logger.info(f"未找到对话指纹 '{fingerprint}'，创建新 chatHistoryId: {chat_history_id}")

        async def stream_generator() -> AsyncGenerator[bytes, None]:
            request_id = f"chatcmpl-{uuid.uuid4()}"
            websocket_uri = f"wss://api.enginelabs.ai/engine-agent/chat-histories/{chat_history_id}/buffer/stream?token={user_id}"
            
            try:
                last_user_message = messages[-1]["content"]
                
                headers = {
                    "Authorization": f"Bearer {jwt_token}",
                    "Content-Type": "application/json",
                    "Origin": "https://cto.new",
                    "Referer": f"https://cto.new/{chat_history_id}",
                }
                
                # 【【【 最终、真正的核心修正 】】】
                # 回归到被证明是正确的、简单的 payload 结构
                payload = {
                    "prompt": last_user_message, # prompt 必须是简单的字符串
                    "chatHistoryId": chat_history_id,
                    "adapterName": model,
                }
                
                logger.info(f"发送 POST 请求，使用 chatHistoryId: {chat_history_id}")
                trigger_response = self.scraper.post(self.chat_url, headers=headers, json=payload, allow_redirects=False)
                
                trigger_response.raise_for_status()
                logger.info(f"POST 请求成功，状态码: {trigger_response.status_code}")

                logger.info(f"正在连接到 WebSocket: {websocket_uri}")
                async with websockets.connect(websocket_uri, origin="https://cto.new") as websocket:
                    logger.info("WebSocket 连接成功，开始监听上游数据...")
                    
                    initial_chunk = create_chat_completion_chunk(request_id, model, "")
                    yield create_sse_data(initial_chunk)

                    while True:
                        message = await websocket.recv()
                        logger.info(f"收到 WebSocket 原始消息: {message}")
                        
                        data = json.loads(message)
                        
                        if data.get("type") == "state" and not data.get("state", {}).get("inProgress"):
                            logger.info("检测到上游任务结束信号，主动关闭流。")
                            break

                        if data.get("type") == "update":
                            buffer_str = data.get("buffer", "{}")
                            try:
                                buffer_data = json.loads(buffer_str)
                                if buffer_data.get("type") == "chat":
                                    content = buffer_data.get("chat", {}).get("content")
                                    if content:
                                        logger.info(f"解析并发送内容: {content}")
                                        chunk = create_chat_completion_chunk(request_id, model, content)
                                        yield create_sse_data(chunk)
                            except json.JSONDecodeError:
                                logger.warning(f"无法解析 WebSocket buffer: {buffer_str}")
                                continue
            
            except Exception as e:
                logger.error(f"处理流时发生错误: {e}", exc_info=True)
                error_message = f"内部错误: {str(e)}"
                error_chunk = create_chat_completion_chunk(request_id, model, error_message, "stop")
                yield create_sse_data(error_chunk)
            finally:
                final_chunk = create_chat_completion_chunk(request_id, model, "", "stop")
                yield create_sse_data(final_chunk)
                logger.info("SSE 流已发送 [DONE] 标志，请求处理完毕。")

        return StreamingResponse(stream_generator(), media_type="text/event-stream")

    async def get_models(self) -> JSONResponse:
        model_data = {
            "object": "list",
            "data": [
                {"id": name, "object": "model", "created": int(time.time()), "owned_by": "lzA6"}
                for name in settings.KNOWN_MODELS
            ]
        }
        return JSONResponse(content=model_data)


--- 文件路径: app\utils\sse_utils.py ---

import json
import time
from typing import Dict, Any, Optional

DONE_CHUNK = b"data: [DONE]\n\n"

def create_sse_data(data: Dict[str, Any]) -> bytes:
    return f"data: {json.dumps(data)}\n\n".encode('utf-8')

def create_chat_completion_chunk(
    request_id: str,
    model: str,
    content: str,
    finish_reason: Optional[str] = None
) -> Dict[str, Any]:
    return {
        "id": request_id,
        "object": "chat.completion.chunk",
        "created": int(time.time()),
        "model": model,
        "choices": [
            {
                "index": 0,
                "delta": {"content": content},
                "finish_reason": finish_reason,
                "logprobs": None
            }
        ],
        "system_fingerprint": "fp_wald_2api"
    }



